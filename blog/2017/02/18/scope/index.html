<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>Scope | Mohit&#39;s Blog</title><meta name="author" content="Mohit Garg"><meta name="description" content="ScopeWhere to look for variables. JavaScript is a compiled language. It is complied every time.var foo = &amp;quot;bar&amp;quot;Grammatically this is a single"><meta name="keywords" content="JavaScript"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="Scope"><meta property="og:site_name" content="Mohit&#39;s Blog"><meta property="og:image" content="/blog/favicon.ico"><link href="/blog/favicon.ico" rel="icon"><link rel="alternate" href="/blog/atom.xml" title="Mohit&#39;s Blog" type="application/atom+xml"><link rel="stylesheet" href="/blog/css/style.css" media="screen" type="text/css"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/blog/">Mohit&#39;s Blog</a></h1><p class="site-description"></p></div><nav class="site-navigation"><ul><li><a href="/blog/">Home</a></li><li><a href="/blog/archives">Archives</a></li><li><a href="/blog/about">About</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>Scope</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/blog/2017/02/18/scope/" rel="bookmark"><time class="entry-date published" datetime="2017-02-18T02:12:35.000Z">2017-Feb-18</time></a></span></div><div class="article-content"><div class="entry"><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>Where to look for variables. JavaScript is a compiled language. It is complied every time.</p><p><code>var foo = &quot;bar&quot;</code></p><p>Grammatically this is a single statement but for JS engine it is 2 different statements. In the first statement JS engine will initialize the variable <em>foo</em> when it is compiling our code and then in the second phase the execution phase variable <em>foo</em> will be set to a value which in this case is the string <em>“bar”.</em></p><p><em>Undefined</em> means it doesn’t currently have a value like an empty place holder.But it definitely has a declared variable.</p><p>As of ES3 the <strong>catch clause</strong> is a <strong>block scope</strong>. A caveat in ECMASCRIPT. Linter still don’t understand the nuance of block scope catch variables.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">catch</span>(err)&#123;</div><div class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// TypeError</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h3><p>It means compiled time scope. Where your variable sits lexically. All the scope decisions will be made during the compiled phase.</p><h3 id="Dynamic-Scope-this"><a href="#Dynamic-Scope-this" class="headerlink" title="Dynamic Scope(this)"></a>Dynamic Scope(this)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">//foo</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bar = <span class="string">"foo"</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line">baz();</div></pre></td></tr></table></figure><p>As we see in lexical scope in function foo that would give an error because the bar doesn’t exist but in dynamic scoping function foo will look for bar in the function it is being called.</p><p>The decision for how scoping works in dynamic scoping is a <strong>runtime decision</strong> as opposed to lexical it’s a <strong>author time</strong> decision.</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>A way to cheat the lexical scoping model that JavaScript has(eval parses it’s argument in statement context)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">eval</span>(str);    <span class="comment">//cheating</span></div><div class="line">  <span class="built_in">console</span>.log(bar);   <span class="comment">//42</span></div><div class="line">&#125;</div><div class="line">foo(<span class="string">"var bar = 42;"</span>);</div></pre></td></tr></table></figure><p>We are passing variable declaration in the form of string in the function foo eval cheats it and pretends that the line of code has existed at compile time. It modifies the existing lexical scope of ‘<em>foo’</em> and add a new declaration to it at run time.Which will then modify the existing scope.</p><p>Just by having eval present in code JS engine will have to disable some of it’s optimizations.</p><p>In <strong>strict mode</strong> it will not disable the optimizations but it will create a new scope for the <em>eval</em> statement.</p><h3 id="with-Keyword"><a href="#with-Keyword" class="headerlink" title="with Keyword"></a>with Keyword</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>;</div><div class="line">  b: <span class="number">3</span>;</div><div class="line">  c: <span class="number">4</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.a = obj.b + obj.c;</div><div class="line">obj.c = obj.b - obj.a;</div><div class="line"></div><div class="line"><span class="keyword">with</span>(obj) &#123;</div><div class="line">  a = b + c;</div><div class="line">  c = b - a;</div><div class="line">  d = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">obj.d;  <span class="comment">//undefined</span></div><div class="line"></div><div class="line">d; <span class="comment">// 3</span></div></pre></td></tr></table></figure><p>As we can see we are repeating the obj reference again and again so to shorthand that we use the <em>with</em> keyword. It can make our code shorter and nice but there are some problems. On line 13 we are intending to create a d property on our <em>obj</em> Object.</p><p>But that’s not how it works it’s first gonna ask the Object obj if it’s got a reference to the <em>d</em> variable and that’s gonna say NO to it so it will go to the outer scope which in this case is the global scope and ask for the reference again. In this case global scope will say YES! I JUST MADE ONE FOR YOU.</p><p><em>With</em> Keyword at runtime is creating a whole new lexical scope which will then effect our JS engine and it will disable it optimizations.</p><p>In <strong>strict mode</strong> <em>with</em> keyword is completely disallowed altogether.</p><h3 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h3><p>Conceptual model how JS works. It’s not physically what actually happens. In ECMASCRIPT specifications there’s no mention of word hoisting anywhere. It’s a mental construct that we have invented to explain the behaviors of JS.</p><p>So the JavaScript engine has two phases one is compiled phase and the other one is execution. All the variable and function are defined or we can say hoisted during the compiled phase.</p><p>Recursion wouldn’t have been possible without hoisting. Like header files we put in the C program are manual hoisting. As compared to JS engine which automatically hoist the values.</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>Every function while executing has a reference to it’s current execution context called <em>this</em>. There are 4 rules for how the this keyword gets bound. They all depend on what we call the CALL SITE. A placing code where a function gets executed.</p><p>Default binding rule- Where the function call is right there after declaration like a normal function call. If we are in strict mode default the this keyword to an undefined value if we are not in strict mode default the this keyword to global object.</p><p><strong>Implicit binding rule</strong> - When there is an Object property reference at the call site the containing object will become this binding.</p><p><strong>Explicit binding rule</strong>- If we use call or apply at the call site both of these methods take this binder as their parameters then the this will point to that Object.</p><p><strong>Hard Binding rule</strong>- Here the this will refer to obj even though we called obj2 in the last line with the call method. This is called hard binding. hiding the original function with a function expression which calls the original function but with a context bound exactly, because both have the same name you can’t have two references with the same name</p><p>one will be hiding the other one.but <em>function foo</em> still alive, and orig is making reference to it</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo)</div><div class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">bar</span> :<span class="string">"bar"</span>&#125;</div><div class="line">  <span class="keyword">var</span> obj2 = &#123;<span class="attr">bar</span> :<span class="string">"bar2"</span>&#125;</div><div class="line">  <span class="keyword">var</span> orig = foo</div><div class="line"></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  orig.call(obj);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(orig)</div><div class="line"><span class="built_in">console</span>.log(foo)</div><div class="line">foo();           <span class="comment">//bar</span></div><div class="line">foo.call(obj2);  <span class="comment">// bar</span></div></pre></td></tr></table></figure><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>When we put the new keyword in front of any function call it magically turns that functional call into a constructor call.when we put a new keyword in front of a function call</p><ol><li><p>A brand new empty is jut magically created out of thin air.</p></li><li><p>That brand new object gets link to a different object.*</p></li><li><p>The brand new object gets bounds as this keyword for the purposes of that function call.</p></li><li><p>If that function otherwise doesn’t return anything it will implicitly insert a return this.</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name , color</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(fluffy , white);</div></pre></td></tr></table></figure><p>this keyword refers to an object. That object is whatever object is executing the current bit of code. by default that is the global object.</p><p>So when we executed this Cat function this was referring to a new empty object. That what new keyword does for us. It creates a new empty JS object. Sets the context of this to that new object and then calls the cat function.</p><p>So this Cat functions are commonly called constructor functions</p></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-tags"><i class="icon-tags"></i> <a href="/blog/tags/JavaScript/">JavaScript</a></span></div></div></article><section id="comments" class="comment"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section><script type="text/javascript">var disqus_shortname="mohit-blog";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}(),function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/count.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></main><footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2017 Mohit Garg</p></footer><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-97252515-1","auto"),ga("send","pageview")</script></div></div></body></html>